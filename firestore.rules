/**
 * @file Firebase Security Rules for Firestore.
 *
 * @Core Philosophy: This ruleset prioritizes secure access to article data,
 * leveraging ownership and structural segregation to enforce fine-grained permissions.
 * Public read access is granted to the `/articles` and `/comments` collections,
 * while write access is restricted to authorized users based on ownership and/or
 * specific article members. All user-specific data is stored under the `/users/{userId}`
 * path, ensuring that only the owning user can access it.
 *
 * @Data Structure:
 * - /articles/{articleId}: Publicly readable articles, with owner-only writes.
 * - /users/{userId}/articles/{articleId}: Articles owned by a specific user, accessible only by that user.
 * - /authors/{authorId}: Publicly readable author profiles.
 * - /categories/{categoryId}: Publicly readable categories.
 * - /comments/{commentId}: Publicly readable comments on articles.
 *
 * @Key Security Decisions:
 * - Public read access to articles and comments.
 * - Strict ownership model for user-specific articles under `/users/{userId}`.
 * - Authors and Categories are publicly accessible.
 * - Listing all documents in `/users/{userId}/articles` is allowed only by the owner.
 *
 * @Denormalization for Authorization:
 * - Articles include `authorId` and `categoryId` to avoid extra reads.
 * - Articles also include a denormalized `members` map for authorization.
 *
 * @Structural Segregation:
 * - Public articles are stored in `/articles`, while private drafts are stored in `/users/{userId}/articles`.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to articles, but restricts writes to the owner (article.authorId).
     * @path /articles/{articleId}
     * @allow (get, list): Anyone can read the articles.
     * @allow (create): Only the author can create an article if `request.auth.uid == request.resource.data.authorId`.
     * @allow (update, delete): Only the author can update or delete an article if `isOwner(resource.data.authorId) && resource != null`.
     * @deny (create): If `request.auth.uid != request.resource.data.authorId`.
     * @deny (update, delete): If the document doesn't exist or the user isn't the owner.
     * @principle Allows public read access with owner-only writes, validating the author ID on creation.
     */
    match /articles/{articleId} {
      allow get: if true;
      allow list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.authorId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows only the owner (the user with matching {userId}) to manage their own articles.
     * @path /users/{userId}/articles/{articleId}
     * @allow (get, list): Only the owner (the user with matching {userId}) can read their own articles.
     * @allow (create): Only the owner (the user with matching {userId}) can create articles. The `id` field in the data MUST match the `userId` in the path.
     * @allow (update, delete): Only the owner (the user with matching {userId}) can update or delete their own articles. The `id` field cannot be changed.
     * @deny (create): If the `id` field in the data doesn't match the `userId` in the path.
     * @deny (update): If the `id` field is changed.
     * @deny (update, delete): If the document doesn't exist.
     * @principle Enforces document ownership for writes and validates relational integrity between the user ID and the article's `id` field.
     */
    match /users/{userId}/articles/{articleId} {
      allow get: if isOwner(userId);
      allow list: if isOwner(userId);
      allow create: if isOwner(userId) && request.resource.data.id == userId;
      allow update: if isOwner(userId) && resource != null && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to author profiles.
     * @path /authors/{authorId}
     * @allow get, list: if true;
     * @deny create, update, delete: if false;
     * @principle Allows public read access, denying all writes.
     */
    match /authors/{authorId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to categories.
     * @path /categories/{categoryId}
     * @allow get, list: if true;
     * @deny create, update, delete: if false;
     * @principle Allows public read access, denying all writes.
     */
    match /categories/{categoryId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to comments.
     * @path /comments/{commentId}
     * @allow get, list: if true;
     * @deny create, update, delete: if false;
     * @principle Allows public read access, denying all writes.
     */
    match /comments/{commentId} {
      allow get: if true;
      allow list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    // Helper functions
    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}