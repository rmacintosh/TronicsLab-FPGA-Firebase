/**
 * @fileOverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset prioritizes security by enforcing strict ownership and explicit access controls.
 * It leverages path-based authorization and denormalized data to minimize reads and optimize performance.
 *
 * Data Structure:
 * - /articles/{articleId}: Publicly readable articles with owner-only writes.
 * - /users/{userId}/articles/{articleId}: Articles owned by a specific user.
 * - /authors/{authorId}: Author profiles.
 * - /categories/{categoryId}: Article categories.
 * - /comments/{commentId}: Comments on articles.
 *
 * Key Security Decisions:
 * - Public read access to the /articles collection to allow open listing.
 * - Strict owner-only access for all write operations on /articles and /users/{userId}/articles.
 * - Listing of collections is only allowed for the owner of a subcollection (e.g., a user can list their own articles).
 * - Data validation is minimized to essential authorization checks, allowing for flexible data shapes during prototyping.
 *
 * Denormalization for Authorization:
 * - The `articles` documents in the `/articles` collection include `authorId` and `categoryId` to avoid needing separate reads to determine access.
 * - The `/users/{userId}/articles` collection is used to establish a clear ownership relationship between a user and their articles, enabling simple path-based authorization.
 *
 * Structural Segregation:
 * - Articles are stored in both `/articles` (public read) and `/users/{userId}/articles` (private write) to allow for public consumption while maintaining strict owner control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Grants public read access to articles and restricts write access to the owner.
     * @path /articles/{articleId}
     * @allow (get, list): Any user (signed in or not) can read the article.
     * @allow (create): Only the article's author can create it, and the `authorId` must match their UID.
     * @allow (update, delete): Only the article's author can modify or delete it.
     * @deny (create): A user attempts to create an article with an `authorId` that doesn't match their UID.
     * @deny (update, delete): A user attempts to modify or delete an article they don't own.
     * @principle Enforces document ownership for writes while allowing public reads.
     */
    match /articles/{articleId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Grants full access to a user for their own articles stored in a private subcollection.
     * @path /users/{userId}/articles/{articleId}
     * @allow (create): The user can create an article with the `id` matching the `articleId` in the path.
     * @allow (get, list, update, delete): The user can read, list, modify, and delete their own articles.
     * @deny (create): A user attempts to create an article where the `articleId` in the path does not match the `id` in the document.
     * @deny (get, list, update, delete): A user attempts to access, modify, or delete another user's article.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/articles/{articleId} {
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == articleId;
      allow get, list, update, delete: if isSignedIn() && isExistingOwner(userId);
    }

    /**
     * @description Grants read and write access to author profiles.
     * @path /authors/{authorId}
     * @allow (get, list): Any user can read the author profile.
     * @allow (create): Any signed-in user can create an author profile.
     * @allow (update, delete): Only the author can modify or delete their own profile.
     * @deny (create): Non-signed-in users cannot create author profiles.
     * @deny (update, delete): A user attempts to modify or delete another author's profile.
     * @principle Enforces document ownership for writes.
     */
    match /authors/{authorId} {
      allow get, list: if true;
      allow create: if isSignedIn();
      allow update, delete: if isSignedIn() && isExistingOwner(authorId);
    }

    /**
     * @description Grants public read access to categories and restricts write access.
     * @path /categories/{categoryId}
     * @allow (get, list): Any user can read the category.
     * @allow (create, update, delete): if false; // TODO: Add role-based access for category management.
     * @deny (create, update, delete): Any user attempts to create, modify, or delete a category.
     * @principle Restricts write access to category data.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add role-based access for category management.
    }

    /**
     * @description Grants read and write access to comments.
     * @path /comments/{commentId}
     * @allow (get, list, create, update, delete): if false; // TODO: Fine tune security rules for comments
     * @deny (get, list, create, update, delete): Any user attempts to read or write comments.
     */
    match /comments/{commentId} {
      allow get, list, create, update, delete: if false; // TODO: Fine tune security rules for comments
    }

    /**
     * @description Prevents listing of the `subCategories` collection.
     * @path /subCategories
     * @allow (list): Denies listing.
     */
    match /subCategories {
        allow list: if false;
        allow get, create, update, delete: if false;
    }

    // ---- Helper functions ----

    /**
     * @description Checks if the user is signed in.
     * @return {boolean} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user is the owner of the document.
     * @param {string} userId The user ID to check against.
     * @return {boolean} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of the document and the document exists.
     * @param {string} userId The user ID to check against.
     * @return {boolean} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}