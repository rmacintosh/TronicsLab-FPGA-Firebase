/**
 * @fileOverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset prioritizes security by enforcing strict ownership and explicit access controls.
 * It leverages path-based authorization and denormalized data to minimize reads and ensure efficient security checks.
 * The rules are designed to be highly restrictive by default, requiring explicit configuration for broader access.
 *
 * Data Structure:
 * - /articles/{articleId}: Stores publicly accessible article data. Includes `authorId` for ownership checks.
 * - /users/{userId}/articles/{articleId}: Stores private articles specific to each user. Enables path-based ownership.
 * - /authors/{authorId}: Stores author information.
 * - /categories/{categoryId}: Stores category information.
 * - /comments/{commentId}: Stores comments associated with articles.
 *
 * Key Security Decisions:
 * - **No User Listing**: Listing all users is explicitly denied. This prevents potential information leakage.
 * - **Path-Based Ownership**: The /users/{userId}/articles/{articleId} collection enforces strict ownership based on the userId in the path.
 * - **Public Read with Owner-Only Write for /articles**: The top-level /articles collection allows public reads but restricts writes to the article's author.
 * - **Denormalization for Authorization**: The `authorId` is denormalized into the `/articles` documents to avoid costly `get()` calls in security rules.
 *
 * Denormalization for Authorization:
 * - The `articles` documents include the `authorId` for immediate ownership checks.
 *
 * Structural Segregation:
 * - Articles are stored in `/articles` for public access and `/users/{userId}/articles` for private, user-specific access.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows public read access to articles, but restricts writes to the author.
     * @path /articles/{articleId}
     * @allow (get, list): if true
     * @allow (create): if request.auth != null && request.resource.data.authorId == request.auth.uid
     * @allow (update, delete): if request.auth != null && resource.data.authorId == request.auth.uid && resource != null
     * @deny (create): if request.auth == null
     * @deny (update, delete): if request.auth == null
     * @deny (update): if request.resource.data.authorId != resource.data.authorId
     * @principle Allows public reads, enforces document ownership for writes, and enforces immutability of authorId.
     */
    match /articles/{articleId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows a user to create, read, update, and delete their own articles.
     * @path /users/{userId}/articles/{articleId}
     * @allow (create): if request.auth != null && request.auth.uid == userId && request.resource.data.id == userId
     * @allow (get, list): if request.auth != null && request.auth.uid == userId
     * @allow (update, delete): if request.auth != null && request.auth.uid == userId && resource != null
     * @deny (create): if request.auth == null || request.auth.uid != userId
     * @deny (get, list): if request.auth == null || request.auth.uid != userId
     * @deny (update, delete): if request.auth == null || request.auth.uid != userId
     * @deny (update): if request.resource.data.id != resource.data.id
     * @principle Enforces document ownership for all operations.  Validates relational integrity on create and update.
     */
    match /users/{userId}/articles/{articleId} {
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow get, list: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows read access to author information. Writes are not permitted.
     * @path /authors/{authorId}
     * @allow get, list: if true
     * @deny create, update, delete: if true
     * @principle Publicly readable author information.
     */
    match /authors/{authorId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read access to categories. Writes are not permitted.
     * @path /categories/{categoryId}
     * @allow get, list: if true
     * @deny create, update, delete: if true
     * @principle Publicly readable category information.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Allows public read and write access to comments.
     * @path /comments/{commentId}
     * @allow get, list, create, update, delete: if true
     */
    match /comments/{commentId} {
      allow get, list, create, update, delete: if true;
    }

    /**
     * @description Prevents listing all users.
     * @path /users
     * @deny list: if true
     * @principle Prevents potential information leakage by disallowing user enumeration.
     */
    match /users {
          allow list: if false;
    }

    /**
     * @description Allows a user to read their own user document
     * @path /users/{userId}
     * @allow get: if request.auth.uid == userId
     * @deny create, update, delete: if true
     */
    match /users/{userId} {
      allow get: if request.auth.uid == userId;
      allow create: if false;
      allow update: if false;
      allow delete: if false;
    }
  }

  function isSignedIn() {
    return request.auth != null;
  }

  function isOwner(userId) {
    return request.auth.uid == userId;
  }

  function isExistingOwner(userId) {
    return isOwner(userId) && resource != null;
  }
}