/**
 * @fileOverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset prioritizes strong authorization and clear ownership, using structural segregation
 * and data denormalization to enhance security and performance. The rules enforce strict
 * ownership for user-specific data while allowing public read access to certain collections.
 *
 * Data Structure:
 * - /articles/{articleId}: Public articles with denormalized authorId and categoryId.
 * - /users/{userId}/articles/{articleId}: Private articles owned by a specific user.
 * - /authors/{authorId}: Author profiles.
 * - /categories/{categoryId}: Article categories.
 * - /comments/{commentId}: Comments on articles.
 *
 * Key Security Decisions:
 * - User listing is generally disallowed unless explicitly required.
 * - Data validation is relaxed to allow for rapid prototyping but critical
 *   authorization and relational integrity checks are enforced.
 * - Public read access is granted to the `/articles` collection, but write access
 *   is restricted to the owner (author).
 *
 * Denormalization for Authorization:
 * The `articles` documents contain a denormalized `members` map to avoid costly `get()` calls and
 * enable efficient authorization checks.  This allows rules to quickly determine if a user has
 * access to an article based on their presence in the `members` map.
 *
 * Structural Segregation:
 * Private user data (e.g., articles under `/users/{userId}/articles`) is stored in
 * user-specific subcollections. Public data (e.g., articles under `/articles`) is stored in
 * top-level collections. This segregation simplifies security rules and improves performance.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows reading public articles. Writing is restricted to the author.
     * @path /articles/{articleId}
     * @allow get, list: if true;
     * @allow create: if request.auth != null && request.resource.data.authorId == request.auth.uid;
     * @allow update: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
     * @allow delete: if isSignedIn() && resource.data.authorId == request.auth.uid && resource != null;
     * @deny create: if request.auth == null;
     * @deny update, delete: if resource == null;
     * @deny create: if request.resource.data.authorId != request.auth.uid;
     * @principle Public read, owner-only writes, relational integrity on create and update.
     */
    match /articles/{articleId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update: if isExistingOwner(resource.data.authorId);
      allow delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows a user to create, read, update, and delete their own articles.
     * @path /users/{userId}/articles/{articleId}
     * @allow create: if request.auth != null && request.auth.uid == userId && request.resource.data.id == userId;
     * @allow get, list: if isSignedIn() && isOwner(userId);
     * @allow update: if isSignedIn() && isOwner(userId) && resource != null && request.resource.data.id == resource.data.id;
     * @allow delete: if isSignedIn() && isExistingOwner(userId);
     * @deny create: if request.auth == null || request.auth.uid != userId;
     * @deny update: if resource == null;
     * @principle Strict user ownership with relational integrity checks.
     */
    match /users/{userId}/articles/{articleId} {
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update: if isExistingOwner(userId) && request.resource.data.id == resource.data.id;
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Allows public read access to author profiles.  Write access is denied.
     * @path /authors/{authorId}
     * @allow get, list: if true;
     * @deny create, update, delete: if true;
     * @principle Public read-only access.
     */
    match /authors/{authorId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to categories. Write access is denied.
     * @path /categories/{categoryId}
     * @allow get, list: if true;
     * @deny create, update, delete: if true;
     * @principle Public read-only access.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows public read access to comments.  Write access is denied.
     * @path /comments/{commentId}
     * @allow get, list: if true;
     * @deny create, update, delete: if true;
     * @principle Public read-only access.
     */
    match /comments/{commentId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

     /**
      * @description Allows public read access to subcategories.  Write access is denied.
      * @path /subCategories/{subcategoryId}
      * @allow get, list: if true;
      * @deny create, update, delete: if true;
      * @principle Public read-only access.
      */
     match /subCategories/{subcategoryId} {
       allow get, list: if true;
       allow create, update, delete: if false;
     }

    function isSignedIn() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isExistingOwner(userId) {
      return isSignedIn() && isOwner(userId) && resource != null;
    }
  }
}