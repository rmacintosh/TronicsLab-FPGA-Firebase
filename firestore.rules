/**
 * @fileoverview Firestore Security Rules for the application.
 *
 * Core Philosophy:
 * This ruleset enforces a combination of public read access for some collections and owner-based write access for others, using a blend of top-level collections and user-scoped subcollections to optimize security and performance.  It also denormalizes authorization data to avoid costly `get()` operations within rules.
 *
 * Data Structure:
 * - /articles/{articleId}: Publicly readable articles, owned by an author.
 * - /users/{userId}/articles/{articleId}: Private articles specific to a user.  This structure is used for simplified ownership checks.
 * - /authors/{authorId}: Information about authors, publicly readable.
 * - /categories/{categoryId}: Information about categories, publicly readable.
 * - /comments/{commentId}: Publicly readable comments.
 *
 * Key Security Decisions:
 * - Public Read Access: The /articles, /authors, /categories and /comments collections are publicly readable.
 * - Owner-Only Writes: Creates, updates, and deletes are restricted to the owner (author) of the article.
 * - Subcollection Ownership: Documents in the /users/{userId}/articles/{articleId} subcollection are owned by the user ID in the path.
 * - No User Listing: Listing all users is disallowed.
 *
 * Denormalization for Authorization:
 *   - The `articles` documents contain an `authorId` field, which is used to verify ownership for write operations.
 *   - The `articles` documents under `/users/{userId}` are implicitly owned by the `userId` in the path.
 *
 * Structural Segregation:
 *   - Public articles are stored in the top-level `/articles` collection, while private user-specific articles are stored in the `/users/{userId}/articles` subcollection.  This allows for different read access patterns.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Allows anyone to read articles, but only the author can create, update, or delete.
     * @path /articles/{articleId}
     * @allow (get, list): Anyone can read articles.
     * @allow (create): User with valid auth can create an article if authorId matches their uid.
     *   Example:
     *   - Request: `create(/articles/article123, {authorId: 'user123', ...})` where `auth.uid == 'user123'`
     * @allow (update, delete): The author of the article can update or delete it.
     *   Example:
     *   - Existing data: `/articles/article123` contains `{authorId: 'user123', ...}`.
     *   - Request: `update(/articles/article123, {title: 'New Title'})` where `auth.uid == 'user123'`
     * @deny (create): User attempts to create an article with an authorId that doesn't match their uid.
     *   Example:
     *   - Request: `create(/articles/article123, {authorId: 'user456', ...})` where `auth.uid == 'user123'`
     * @deny (update, delete): A non-author attempts to update or delete an article.
     *   Example:
     *   - Existing data: `/articles/article123` contains `{authorId: 'user123', ...}`.
     *   - Request: `update(/articles/article123, {title: 'New Title'})` where `auth.uid == 'user456'`
     * @principle Enforces public read access with owner-only writes and validates authorId on create.
     */
    match /articles/{articleId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows a user to manage their own articles in their private subcollection.
     * @path /users/{userId}/articles/{articleId}
     * @allow (get, list): The owner can read their own articles.
     *   Example: `get(/users/user123/articles/article456)` where `auth.uid == 'user123'`
     * @allow (create): The owner can create an article in their own subcollection if the userId matches the articleId.
     *   Example: `create(/users/user123/articles/article456, {id: 'user123'})` where `auth.uid == 'user123'`
     * @allow (update, delete): The owner can update or delete their own articles.
     *   Example:
     *   - Existing data: `/users/user123/articles/article456` exists.
     *   - Request: `update(/users/user123/articles/article456, {title: 'New Title'})` where `auth.uid == 'user123'`
     * @deny (get, list): A non-owner attempts to read articles from another user's subcollection.
     *   Example: `get(/users/user123/articles/article456)` where `auth.uid == 'user456'`
     * @deny (create): A user attempts to create an article in another user's subcollection, or if the userId does not matches the articleId.
     *   Example: `create(/users/user123/articles/article456, {id: 'user456'})` where `auth.uid == 'user456'`
     * @deny (update, delete): A non-owner attempts to update or delete an article in another user's subcollection.
     *   Example:
     *   - Existing data: `/users/user123/articles/article456` exists.
     *   - Request: `update(/users/user123/articles/article456, {title: 'New Title'})` where `auth.uid == 'user456'`
     * @principle Enforces strict user-ownership for all operations on articles within the user's subcollection.
     */
    match /users/{userId}/articles/{articleId} {
      allow get, list: if isSignedIn() && isOwner(userId);
      allow create: if isSignedIn() && isOwner(userId) && request.resource.data.id == userId;
      allow update, delete: if isSignedIn() && isExistingOwner(userId) && request.resource.data.id == resource.data.id;
    }

    /**
     * @description Allows anyone to read author information.
     * @path /authors/{authorId}
     * @allow (get, list): Anyone can read author information.
     * @deny (create, update, delete): No one can create, update, or delete author information through the client.
     * @principle Enforces public read-only access.
     */
    match /authors/{authorId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows anyone to read category information.
     * @path /categories/{categoryId}
     * @allow (get, list): Anyone can read category information.
     * @deny (create, update, delete): No one can create, update, or delete category information through the client.
     * @principle Enforces public read-only access.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    /**
     * @description Allows anyone to read comments.
     * @path /comments/{commentId}
     * @allow (get, list): Anyone can read comments.
     * @deny (create, update, delete): No one can create, update, or delete comments through the client.
     * @principle Enforces public read-only access.
     */
    match /comments/{commentId} {
      allow get, list: if true;
      allow create, update, delete: if false;
    }

    // ---- Helper functions ----

    /**
     * @description Checks if the user is signed in.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the requesting user is the owner of the resource.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the user is the owner, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the requesting user is the owner of the resource and if the resource exists.
     * @param {string} userId The user ID to check against.
     * @return {bool} True if the user is the owner and the resource exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }
  }
}